// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PtzChannel ptz channel
//
// swagger:model PtzChannel
type PtzChannel struct {

	// r s485 baud rate
	RS485BaudRate int64 `json:"RS485BaudRate,omitempty" xml:"PTZChannel>PTZRs485Para>baudRate,omitempty"`

	// r s485 data bits
	RS485DataBits int64 `json:"RS485DataBits,omitempty" xml:"PTZChannel>PTZRs485Para>dataBits,omitempty"`

	// r s485 flow control
	// Enum: [none software hardware]
	RS485FlowControl string `json:"RS485FlowControl,omitempty" xml:"PTZChannel>PTZRs485Para>flowCtrl,omitempty"`

	// r s485 parity type
	// Enum: [none even odd mark space]
	RS485ParityType string `json:"RS485ParityType,omitempty" xml:"PTZChannel>PTZRs485Para>parityType,omitempty"`

	// r s485 stop bits
	RS485StopBits float64 `json:"RS485StopBits,omitempty" xml:"PTZChannel>PTZRs485Para>stopBits,omitempty"`

	// auto patrol speed
	AutoPatrolSpeed int64 `json:"autoPatrolSpeed,omitempty" xml:"PTZChannel>autoPatrolSpeed,omitempty"`

	// control address
	ControlAddress string `json:"controlAddress,omitempty" xml:"PTZChannel>controlAddress>Address,omitempty"`

	// control enabled
	ControlEnabled bool `json:"controlEnabled,omitempty" xml:"PTZChannel>controlAddress>enabled,omitempty"`

	// control protocol
	ControlProtocol string `json:"controlProtocol,omitempty" xml:"PTZChannel>controlProtocol,omitempty"`

	// default preset ID
	DefaultPresetID string `json:"defaultPresetID,omitempty" xml:"PTZChannel>defaultPresetID,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty" xml:"PTZChannel>enabled,omitempty"`

	// id
	ID uint64 `json:"id,omitempty" xml:"PTZChannel>id,omitempty"`

	// key board control speed
	KeyBoardControlSpeed string `json:"keyBoardControlSpeed,omitempty" xml:"PTZChannel>keyBoardControlSpeed,omitempty"`

	// manual control speed
	// Enum: [pedestrian nonMotorVehicle motorVehicle selfadaptive compatible]
	ManualControlSpeed string `json:"manualControlSpeed,omitempty" xml:"PTZChannel>manualControlSpeed,omitempty"`

	// pan max speed
	PanMaxSpeed int64 `json:"panMaxSpeed,omitempty" xml:"PTZChannel>panMaxSpeed,omitempty"`

	// pan support
	PanSupport bool `json:"panSupport,omitempty" xml:"PTZChannel>panSupport,omitempty"`

	// preset speed
	PresetSpeed int64 `json:"presetSpeed,omitempty" xml:"PTZChannel>presetSpeed,omitempty"`

	// tilt max speed
	TiltMaxSpeed int64 `json:"tiltMaxSpeed,omitempty" xml:"PTZChannel>tiltMaxSpeed,omitempty"`

	// tilt support
	TiltSupport bool `json:"tiltSupport,omitempty" xml:"PTZChannel>tiltSupport,omitempty"`

	// video input ID
	VideoInputID uint64 `json:"videoInputID,omitempty" xml:"PTZChannel>videoInputID,omitempty"`

	// zoom support
	ZoomSupport bool `json:"zoomSupport,omitempty" xml:"PTZChannel>zoomSupport,omitempty"`
}

// Validate validates this ptz channel
func (m *PtzChannel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRS485FlowControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRS485ParityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManualControlSpeed(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var ptzChannelTypeRS485FlowControlPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","software","hardware"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ptzChannelTypeRS485FlowControlPropEnum = append(ptzChannelTypeRS485FlowControlPropEnum, v)
	}
}

const (

	// PtzChannelRS485FlowControlNone captures enum value "none"
	PtzChannelRS485FlowControlNone string = "none"

	// PtzChannelRS485FlowControlSoftware captures enum value "software"
	PtzChannelRS485FlowControlSoftware string = "software"

	// PtzChannelRS485FlowControlHardware captures enum value "hardware"
	PtzChannelRS485FlowControlHardware string = "hardware"
)

// prop value enum
func (m *PtzChannel) validateRS485FlowControlEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ptzChannelTypeRS485FlowControlPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PtzChannel) validateRS485FlowControl(formats strfmt.Registry) error {

	if swag.IsZero(m.RS485FlowControl) { // not required
		return nil
	}

	// value enum
	if err := m.validateRS485FlowControlEnum("RS485FlowControl", "body", m.RS485FlowControl); err != nil {
		return err
	}

	return nil
}

var ptzChannelTypeRS485ParityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","even","odd","mark","space"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ptzChannelTypeRS485ParityTypePropEnum = append(ptzChannelTypeRS485ParityTypePropEnum, v)
	}
}

const (

	// PtzChannelRS485ParityTypeNone captures enum value "none"
	PtzChannelRS485ParityTypeNone string = "none"

	// PtzChannelRS485ParityTypeEven captures enum value "even"
	PtzChannelRS485ParityTypeEven string = "even"

	// PtzChannelRS485ParityTypeOdd captures enum value "odd"
	PtzChannelRS485ParityTypeOdd string = "odd"

	// PtzChannelRS485ParityTypeMark captures enum value "mark"
	PtzChannelRS485ParityTypeMark string = "mark"

	// PtzChannelRS485ParityTypeSpace captures enum value "space"
	PtzChannelRS485ParityTypeSpace string = "space"
)

// prop value enum
func (m *PtzChannel) validateRS485ParityTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ptzChannelTypeRS485ParityTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PtzChannel) validateRS485ParityType(formats strfmt.Registry) error {

	if swag.IsZero(m.RS485ParityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRS485ParityTypeEnum("RS485ParityType", "body", m.RS485ParityType); err != nil {
		return err
	}

	return nil
}

var ptzChannelTypeManualControlSpeedPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pedestrian","nonMotorVehicle","motorVehicle","selfadaptive","compatible"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ptzChannelTypeManualControlSpeedPropEnum = append(ptzChannelTypeManualControlSpeedPropEnum, v)
	}
}

const (

	// PtzChannelManualControlSpeedPedestrian captures enum value "pedestrian"
	PtzChannelManualControlSpeedPedestrian string = "pedestrian"

	// PtzChannelManualControlSpeedNonMotorVehicle captures enum value "nonMotorVehicle"
	PtzChannelManualControlSpeedNonMotorVehicle string = "nonMotorVehicle"

	// PtzChannelManualControlSpeedMotorVehicle captures enum value "motorVehicle"
	PtzChannelManualControlSpeedMotorVehicle string = "motorVehicle"

	// PtzChannelManualControlSpeedSelfadaptive captures enum value "selfadaptive"
	PtzChannelManualControlSpeedSelfadaptive string = "selfadaptive"

	// PtzChannelManualControlSpeedCompatible captures enum value "compatible"
	PtzChannelManualControlSpeedCompatible string = "compatible"
)

// prop value enum
func (m *PtzChannel) validateManualControlSpeedEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, ptzChannelTypeManualControlSpeedPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PtzChannel) validateManualControlSpeed(formats strfmt.Registry) error {

	if swag.IsZero(m.ManualControlSpeed) { // not required
		return nil
	}

	// value enum
	if err := m.validateManualControlSpeedEnum("manualControlSpeed", "body", m.ManualControlSpeed); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PtzChannel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PtzChannel) UnmarshalBinary(b []byte) error {
	var res PtzChannel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
